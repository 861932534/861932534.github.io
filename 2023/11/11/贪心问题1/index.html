<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>贪心问题1</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="23-11-15一、删除问题二、陶陶摘苹果（升级版）—-贪心问题方法1（我的解法）：
思路：使用pair来存储高度和体力值，用sort两次排序。第一次按高度从小到大排序（排序范围：1-n），第二次在第一次的基础上按体力值从小到大排序（排序范围1-cnt&amp;#x2F;&amp;#x2F;cnt是小于等于淘淘能够够到的高度的苹果的数量）。然后用循环扫一遍就可以。
代码：
123456789101112131415161718192021222324252627282930#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int N=1e4;typedef pair&amp;lt;int,int&amp;gt; PII;PII x[N];int n,s,a,b;bool cmp(.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Haojen's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">贪心问题1</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#23-11-15"><span class="toc-text">23-11-15</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-text">一、删除问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%99%B6%E9%99%B6%E6%91%98%E8%8B%B9%E6%9E%9C%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%E2%80%94-%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98"><span class="toc-text">二、陶陶摘苹果（升级版）—-贪心问题</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">贪心问题1</h1><time class="has-text-grey" datetime="2023-11-11T09:07:12.000Z">2023-11-11</time><article class="mt-2 post-content"><h1 id="23-11-15"><a href="#23-11-15" class="headerlink" title="23-11-15"></a>23-11-15</h1><h2 id="一、删除问题"><a href="#一、删除问题" class="headerlink" title="一、删除问题"></a>一、删除问题</h2><h2 id="二、陶陶摘苹果（升级版）—-贪心问题"><a href="#二、陶陶摘苹果（升级版）—-贪心问题" class="headerlink" title="二、陶陶摘苹果（升级版）—-贪心问题"></a>二、陶陶摘苹果（升级版）—-贪心问题</h2><p>方法1（我的解法）：</p>
<p>思路：使用pair来存储高度和体力值，用sort两次排序。第一次按高度从小到大排序（排序范围：1-n），第二次在第一次的基础上按体力值从小到大排序（排序范围1-cnt&#x2F;&#x2F;cnt是小于等于淘淘能够够到的高度的苹果的数量）。然后用循环扫一遍就可以。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e4;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">PII x[N];</span><br><span class="line">int n,s,a,b;</span><br><span class="line">bool cmp(PII a,PII b)&#123;</span><br><span class="line">	return a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x[i].first&gt;&gt;x[i].second;</span><br><span class="line">		if(x[i].first&lt;=a+b) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x,x+n);</span><br><span class="line">	sort(x,x+cnt,cmp);</span><br><span class="line">	int res=0;</span><br><span class="line">	for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">		if(s&gt;=x[i].second)&#123;</span><br><span class="line">			res++;</span><br><span class="line">			s-=x[i].second;</span><br><span class="line">			//cout&lt;&lt;x[i].first&lt;&lt;x[i].second&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法2：使用dfs，搭配剪枝，使用变量存储来减少函数的调用以及记忆化搜索来降低时间复杂度。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n,s,a,b;</span><br><span class="line">bool visit[5005][5005];//记忆化搜索</span><br><span class="line">int mem[5005][5005];</span><br><span class="line">struct apple &#123;</span><br><span class="line">	int xi,yi;</span><br><span class="line">&#125;ap[5005];</span><br><span class="line">int dfs(int num,int rest)&#123;</span><br><span class="line">	if(num&gt;n||a+b&lt;ap[num].xi) return 0;//剪枝 </span><br><span class="line">	if(visit[num][rest]) return mem[num][rest];</span><br><span class="line">	visit[num][rest]=true;</span><br><span class="line">	int maxn=dfs(num+1,rest);//减少函数的调用 </span><br><span class="line">	if(ap[num].xi&lt;=a+b&amp;&amp;rest&gt;=ap[num].yi)&#123;</span><br><span class="line">		int t= dfs(num+1,rest-ap[num].yi)+1;//减少函数的调用</span><br><span class="line">		maxn=t&gt;maxn?t:maxn;</span><br><span class="line">	&#125;</span><br><span class="line">	return mem[num][rest]=maxn; </span><br><span class="line">&#125; 	</span><br><span class="line"></span><br><span class="line">bool cmp(apple a,apple b)&#123;//从小到大 </span><br><span class="line">	return a.xi&lt;b.xi;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;//苹果个数，体力值，板凳高度，伸长手高度 </span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin&gt;&gt;ap[i].xi&gt;&gt;ap[i].yi;</span><br><span class="line">	sort(ap+1,ap+n+1,cmp);</span><br><span class="line">	cout&lt;&lt;dfs(1,s);	//面对第一个苹果，体力值为s </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3、dp（动态规划），比较简单的01背包问题</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n,s,a,b;</span><br><span class="line">int xi[5005],yi[5005];</span><br><span class="line">int dp[5005][1001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;xi[i]&gt;&gt;yi[i];</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=0;j&lt;=s;j++)&#123;	//j为什么是从零开始的，因为体力可以为零 </span><br><span class="line">			dp[i][j]=dp[i-1][j];</span><br><span class="line">			if(xi[i]&lt;=a+b&amp;&amp;j&gt;=yi[i])</span><br><span class="line">			//dp[i][j]=max(dp[i-1][j-yi[i]]+1,dp[i][j]);max函数很慢，使用三目运算比较快 </span><br><span class="line">			dp[i][j]=dp[i-1][j-yi[i]]+1&gt;dp[i][j]?dp[i-1][j-yi[i]]+1:dp[i][j];</span><br><span class="line">            //状态转移方程</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][s]&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法4、桶排序     知识点： ( <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27198345/article/details/126516234?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170004275716800213091668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170004275716800213091668&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126516234-null-null.142%5Ev96%5Epc_search_result_base5&utm_term=%E6%A1%B6%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">1</a>    <a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/bucket-sort/">2</a>  )   视频：（<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A4411N7cG/?spm_id_from=333.337.search-card.all.click&vd_source=6e52c3c8a1f4d6daf5e4cac5a4b8bd8b">1</a>）</p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/skill/detail/acm/1296">相关题目</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/11/16/stl%E5%AE%B9%E5%99%A8/" title="stl容器"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: stl容器</span></a><a class="button is-default" href="/2023/10/15/hello-world/" title="Hello World"><span class="has-text-weight-semibold">Next: Hello World</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haojen"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Haojen 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>